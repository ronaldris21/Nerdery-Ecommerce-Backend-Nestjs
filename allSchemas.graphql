
# GENERIC FILE: _ENUMS.GENERIC.GRAPHQL


# ENUMS
enum GenderEnum {
  MALE
  FEMALE
  UNISEX
}

enum SortingProductEnum {
  FROM_A_TO_Z
  FROM_Z_TO_A
  FROM_HIGHEST_PRICE
  FROM_LOWEST_PRICE
  RECENT_UPDATED
  LATEST_UPDATED
  MOST_POPULAR
  LESS_POPULAR
}

enum DiscountTypeEnum {
  PERCENTAGE # "%"
  DOLLAR_SIGN # "$"
}

enum OrderStatusEnum {
  WAITING_PAYMENT
  PAYMENT_APPROVED
  CANCELED
  COMPLETED
}

enum StripePaymentIntentEnum {
  REQUIRES_PAYMENT_METHOD
  REQUIRES_CONFIRMATION
  REQUIRES_ACTION
  PROCESSING
  SUCCEEDED
  REQUIRES_CAPTURE
  CANCELED
  FAILED
}

# GENERIC FILE: _SCALARS.GENERIC.GRAPHQL


# npm i graphql-scalars
# https://the-guild.dev/graphql/scalars/docs/quick-start
scalar DateTime


# npm i  graphql-upload@14
# https://dev.to/elbarryamine/how-to-upload-files-with-nestjs-and-graphql-2iig
scalar Upload


# GENERIC FILE: _TYPES.GENERIC.GRAPHQL


type ValidationError {
  property: String!
  constraint: [String!]!
}

type GenericResponse {
  success: Boolean!
  message: String
  httpCode: Int!
  errors: [ValidationError!]
}




type CartItem {
  # Database persisted fields
  userId: ID!
  productVariationId: ID!
  quantity: Int!
}

type CartItemPayload {
  # Database persisted fields
  userId: ID!
  productVariationId: ID!
  quantity: Int!

  # Calculated fields on the server
  unitPrice: Float!
  subTotal: Float!
  discount: Float!
  total: Float!

  # Resolved field via DataLoader
  productVariation: ProductVariation!
}

type CartPayload {
  items: [CartItemPayload!]!

  # Calculate fields on the server from all items in the cart
  subTotal: Float!
  discount: Float!
  total: Float!
}

input CartItemInput {
  productVariationId: ID!
  quantity: Int!
}

# CATEGORY DEFINITIONS
type Category {
  id: ID!
  name: String!
  parentCategoryId: ID

  parentCategory: Category
  subcategories: [Category]
}

type CategoryQuery {
  # If no name is provided, return all categories.
  categories(search: String): [Category!]!
}
# This is a dedicated endpoint for managing loose inventory items.
# This endpoint is also called every 1 hours by a CRON JOB.
# Its purpose is to replenish the stock of orders that have not been completed in more than 4 hours. Giving other customers the opportunity to buy the variation products
# This endpoint can also be triggered by a manager.
# There are high availability cases where holding stock for 4 hours is too much. Managers can make a request using the minutes query to clean up orders and restore stock from orders that have not been completed in more than X minutes. The minimun minutes accepted is 10.

type RestoreItem {
  productVariationId: ID!
  quantity: Int!
}

type RestoreStockPayload {
  OrderId: ID!
  items: [RestoreItem!]!
}

type CleanUpMutation {
  # Managers only
  # Replenishes failed orders stock back (Managers or via CRON JOB)
  # minutes (optional): How many minutes has the order been without payment. If more than the limit, stock is replenished.
  cleanupOrders(minutes: Int): [RestoreStockPayload!]!
}
type Order {
  id: ID!
  userId: ID!
  currency: String!
  subTotal: Float!
  discount: Float!
  total: Float!
  status: OrderStatusEnum!
  createdAt: DateTime!
  updatedAt: DateTime!
  isDeleted: Boolean!
  isStockReserved: Boolean!

  user: User
  items: [OrderItem!]!
  payments: [StripePayment!]!
  incidents: [OrderIncident!]!
}

type ApprovedStatusPayload {
  isApproved: Boolean!
}

type CreateOrderPayload {
  order: Order!
  stripePaymentId: String!
}

# QUERY FILTER INPUTS
input OrderFilterInput {
  status: OrderStatusEnum
  afterDate: String
  beforeDate: String
}

# ORDER INCIDENT DEFINITIONS
type OrderIncident {
  id: ID!
  managerId: ID!
  clientId: ID!
  orderId: ID!
  withRestock: Boolean!
  withRefund: Boolean!
  refund: Float!
  reason: String!
  currency: String!
  totalPrice: Float!
  createdAt: DateTime!
  
  manager: User
  client: User
  order: Order
}

# INPUTS
input CreateOrderIncidentInput {
  orderId: ID!
  reason: String!
  withRestock: Boolean!
  withRefund: Boolean!
  refund: Float!
  currency: String!
}

# ORDER ITEM DEFINITIONS
type OrderItem {
  id: ID!
  orderId: ID!
  productVariationId: ID!
  unitPrice: Float!
  quantity: Int!
  subTotal: Float!
  discount: Float!
  total: Float!

  order: Order
  productVariation: ProductVariation
}

# No queries nor mutations needed
# Data is retrieve from the Order Queries, using ResolveFields with DataLoaders to request all data avoiding n+1 problem
# No types needed
# This data is used by services only
# No types needed
# This data is used by services only
# PRODUCT DEFINITIONS
type Product {
  id: ID!
  name: String!
  gender: GenderEnum!
  thumbnailUrl: String
  categoryId: ID!
  description: String
  isEnabled: Boolean!
  isDeleted: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!

  # Calculate values on likes, dislikes, productVariation (post, update, delete)
  likesCount: Int!
  minPrice: Float
  maxPrice: Float

  myLike: Boolean! # @ResolvedField if requested
  category: Category!
  productVariations: [ProductVariation!]! # @ResolvedField if requested - DataLoaders needed 
}

type PaginationDetails {
  totalItems: Int!
  totalPages: Int!
  limit: Int!
  page: Int!
}

type ProductPagination {
  collection: [Product!]!
  meta: PaginationDetails!
}

# INPUTS

input AddProductInput {
  name: String!
  gender: GenderEnum!
  categoryId: ID!
  description: String!
  isEnabled: Boolean!
}

input UpdateProductInput {
  name: String
  gender: GenderEnum
  categoryId: ID
  description: String
  isEnabled: Boolean
}


input ProductFiltersInput {
  gender: GenderEnum
  categoryId: ID
  search: String
  minPrice: Float
  maxPrice: Float
}

# PAGINATION:
input PaginationInput {
  page: Int = 1
  limit: Int = 20
}

# PRODUCT LIKE DEFINITIONS
type ProductLike {
  userId: ID!
  productId: ID!
  likedAt: DateTime!
}

type likesMutation {
  # Clients only
  likeProduct(productId: ID!): GenericResponse!

  # Clients only
  dislikeProduct(productId: ID!): GenericResponse!
}
# PRODUCT VARIATION DEFINITIONS
type ProductVariation {
  id: ID!
  price: Float!
  discount: Float
  discountType: DiscountTypeEnum
  size: String!
  color: String!
  stock: Int!
  stockRefilledAt: String!
  isEnabled: Boolean!
  isDeleted: Boolean!

  images: [String!]! # Resolved field via DataLoader when parent is ProductVariation
  product: Product! # Resolved field via DataLoader when parent is OrderItem or CartItem
  variationImages: [VariationImage!]!
}

# INPUTS
input AddProductVariationInput {
  price: Float!
  discount: Float
  discountType: DiscountTypeEnum
  size: String!
  color: String!
  stock: Int!
  isEnabled: Boolean!
}

input UpdateProductVariationInput {
  productId: ID
  price: Float
  discount: Float
  discountType: DiscountTypeEnum
  size: String
  color: String
  stock: Int
  isEnabled: Boolean
}

# No types needed
# This data is used by services only
# No types needed
# This data is used by services only
# No types needed
# This data is used by services only
# STRIPE PAYMENTS DEFINITIONS
type StripePayment {
  id: ID!
  orderId: ID!
  amount: Float!
  currency: String!
  stripePaymentId: String!
  webhookPaymentIntent: StripePaymentIntentEnum!
  webhookData: String
  createdAt: DateTime!
  updatedAt: DateTime!

  order: Order
}
type User {
  id: ID!
  firstName: String!
  lastName: String!
  email: String!
  createdAt: DateTime!
}

# PAYLOADS
type Me {
  id: ID!
  firstName: String!
  lastName: String!
  email: String!
  roles: [String!]!
}

type AuthPayload {
  accessToken: String!
  refreshToken: String!
  exp: Int! # expiration time in seconds
  roles: [String!]!
}

# INPUTS
input SignUpInput {
  firstName: String!
  lastName: String!
  email: String!
  password: String!
}

input SignInInput {
  email: String!
  password: String!
}
input RefreshAndAccessTokenInput {
  refreshToken: String!
  accessToken: String!
}

input ResetPasswordInput {
  resetToken: String!
  newPassword: String!
}

# No types needed
# This data is used by services only
# scalar Upload
# https://aws.plainenglish.io/building-graphql-api-for-effortless-file-uploads-to-aws-s3-cf9ba8b5bd12

type VariationImage {
  id: ID!
  url: String!
  productVariationId: ID!
}

# INPUTS
input UploadThumbnailInput {
  productId: ID!
  file: Upload!
}

input UploadVariationImagesInput {
  productVariationId: ID!
  files: [Upload!]!
}


# CONSOLIDATED QUERIES
type Query {

  # CARTITEM FILE QUERIES:
  # Clients only
  myCart: CartPayload!

  # CATEGORY FILE QUERIES:

  # CLEANUPORDERS FILE QUERIES:

  # ORDER FILE QUERIES:
  # Managers: Can retrieve all orders.
  # Clients: Can only access their own orders.
  orders(filter: OrderFilterInput): [Order!]!

  # Managers can access any order
  # Clients can only access their own order
  order(id: ID!): Order

  # Manager: Returns all payments
  # Client: Returns only the last payment info generated
  orderPayments(id: ID!): [StripePayment!]!

  # Check if payment was successfully approved from Stripe
  # Managers can access to any order && Clients can access their own orders
  orderPaymentApprovedStatus(id: ID!): ApprovedStatusPayload!

  # ORDERINCIDENT FILE QUERIES:
  # Managers only
  # Optionally filter by userId (clientId) or orderId to get a specific order
  # if not provided, all incidents are returned
  orderIncidents(clientId: ID, orderId: ID): [OrderIncident!]!

  # ORDERITEM FILE QUERIES:

  # PASSWORDRESET FILE QUERIES:

  # PERMISSION FILE QUERIES:

  # PRODUCT FILE QUERIES:
  products(
    pagination: PaginationInput
    filter: ProductFiltersInput
    sortBy: SortingProductEnum
  ): ProductPagination!

  # Clients only
  myLikedProducts(
    pagination: PaginationInput
    filter: ProductFiltersInput
    sortBy: SortingProductEnum
  ): ProductPagination!

  product(id: ID!): Product!

  # PRODUCTLIKE FILE QUERIES:

  # PRODUCTVARIATION FILE QUERIES:
  ProductVariations(productId: ID!): [ProductVariation!]!
  productVariation(id: ID!): ProductVariation

  # REFRESHTOKEN FILE QUERIES:

  # ROLE FILE QUERIES:

  # ROLEPERMISSION FILE QUERIES:

  # STRIPEPAYMENT FILE QUERIES:

  # USER FILE QUERIES:
  # Get logged user data
  me: Me

  # USERROLE FILE QUERIES:

  # VARIATIONIMAGE FILE QUERIES:
  variationImages(variationProductId: ID!): [VariationImage!]!
}

# CONSOLIDATED MUTATIONS
type Mutation {

  # CARTITEM FILE MUTATIONS:
  # Clients only
  addCartItem(input: CartItemInput!): CartItem!
  # Clients only
  updateCartItem(input: CartItemInput!): CartItem!
  # Clients only
  deleteCartItem(productVariationId: ID!): GenericResponse!

  # CATEGORY FILE MUTATIONS:

  # CLEANUPORDERS FILE MUTATIONS:

  # ORDER FILE MUTATIONS:
  # Clients only
  # Transforms Cart-Items into an actual order and initiates payment.
  createOrder: CreateOrderPayload!

  # Clients only
  # Delete an order if payment is not completed
  # Clients can only delete their own order if not paid
  deleteOrder(id: ID!): GenericResponse!

  # Managers only
  # For example: from waiting_payment to payment_approved or completed
  updateOrderStatus(id: ID!, newStatus: OrderStatusEnum!): Order!

  # Managers or Clients
  # Create another stripe_payment_id for an existing order (Clients or Managers)
  # If not enough stock, returns an error and reverts partial stock to cart.
  retryOrderPayment(id: ID!): CreateOrderPayload!

  # ORDERINCIDENT FILE MUTATIONS:
  # Managers only
  # Creates an order incident and set the order as deleted
  createOrderIncident(input: CreateOrderIncidentInput!): OrderIncident!

  # ORDERITEM FILE MUTATIONS:

  # PASSWORDRESET FILE MUTATIONS:

  # PERMISSION FILE MUTATIONS:

  # PRODUCT FILE MUTATIONS:
  # Managers only
  addProduct(input: AddProductInput!): Product!

  # Managers only
  updateProduct(id: ID!, input: UpdateProductInput!): Product!

  # Managers only
  deleteProduct(id: ID!): GenericResponse!

  # PRODUCTLIKE FILE MUTATIONS:

  # PRODUCTVARIATION FILE MUTATIONS:
  # Managers only
  addProductVariation(
    productId: ID!
    input: AddProductVariationInput!
  ): ProductVariation!

  # Managers only
  updateProductVariation(
    id: ID!
    input: UpdateProductVariationInput!
  ): ProductVariation!

  # Managers only
  deleteProductVariation(id: ID!): GenericResponse!

  # REFRESHTOKEN FILE MUTATIONS:

  # ROLE FILE MUTATIONS:

  # ROLEPERMISSION FILE MUTATIONS:

  # STRIPEPAYMENT FILE MUTATIONS:

  # USER FILE MUTATIONS:
  signUp(input: SignUpInput!): GenericResponse!

  signIn(input: SignInInput!): AuthPayload!

  # Invalidate the provided refresh token from the database, and access token from the redis cache layer
  signOut(input: RefreshAndAccessTokenInput!): GenericResponse!

  # Sends a reset Token to the user's email if it exists
  forgotPassword(email: String!): GenericResponse!

  #  Use the reset Token from forgotPassword email and sets the new password for the user
  resetPassword(input: ResetPasswordInput!): AuthPayload!

  # Returns new tokens
  refreshToken(input: RefreshAndAccessTokenInput!): AuthPayload!

  # USERROLE FILE MUTATIONS:

  # VARIATIONIMAGE FILE MUTATIONS:
  # Managers only
  uploadProductThumbnail(input: UploadThumbnailInput!): Product!

  # Managers only
  uploadVariationImages(input: UploadVariationImagesInput!): VariationImage!

  # Managers only
  deleteVariationImage(id: ID!): GenericResponse!
}
